Twisted Oblivion
================

Overview
--------
_Provide a detailed description of the encryption process: specifying how the key is obtained, how messages are encrypted, and how the ciphertext is computed._

In this challenge, we were introduced to a website that encrypts a given message.
Looking through the source code, we can see that the encryption algorithm consists in applying the operation Exclusive-OR(XOR) to a message and a certain key.
This message that is going to be encrypted corresponds to the given message put together with a padding and a flag. The website presents the string resulting from this encryption, in other words, it presents the ciphertext.
The key used in the encryption is going to be obtained using a pseudorandom number generated that was initialized with a random seed. This pseudorandom number generator is going to generate a new key value using a certain algorithm. In the case of this website, as we are using the python's library *random* and the function "rnd.getrandbits(32)" to obtain the values of the key, the algorithm used is the Mersenne Twister.
Each value resulting from Mersenne Twister is going to be divided into 4 key values. Each one of these key values is going to be used together with one char of the message. Therefore, we are going to have a key with the size of the message.


Vulnerability
-------------
_Briefly describe the vulnerability in the encryption process and why the choice of the pseudorandom number generator (PRNG) is critical in this application._

When we read the introduction of the python's library *random*, we can find the warning _"The pseudo-random generators of this module should not be used for security purposes."_. We can also read that this library uses as core generator the Mersenne Twister. This generator has a vulnerability. After 624 executions of this algorithm, if we discover the value of the key, we can determine the following values to be generated.
This is critical because the key stops being random and starts being deterministic. In this context, as the security depends on the PRNG (this choice is essential to keep the perfect secrecy of the encryption scheme), it needs to be unpredictable, in order words, it needs to hide not only the seed but it can't allow the following random values to be predictable. Which is not the case. Making the encryption scheme vulnerable and not secure.
Knowing of this vulnerability, we are going to try and execute an active attack.



Exploitation
------------
_Explain how you obtained the flag by exploiting the program. Although the solution can be computed without an automated constraint solver, we require using Z3 to break the PRNG._

_Please include references to all on-line resources that you used to solve the challenge. Note anyway that your solution __must__ be original._


As we saw in our analysis of the source code, a padding section and a flag are appended to our message. Therefore, in order to complete this challenge, we need to decipher the message printed by the webpage.
To do so, we are going to be performing an active attack, more specifically, a chosen plaintext attack, where we are going to give the webpage a certain message, and with the received encrypted message build our decryption algorithm to decipher all of the message.

With the plaintext and the ciphertext, we are going to be determining the key used to encode the part of the message sent by us. If the PRNG was secure, with this information we would not be able to determine the key used to encrypt the rest of the message, more precisely the key that encrypts the flag. However, the Mersenne Twister is not secure.
This algorithm generates its values using a known algorithm and in function of an array of states. This array of states has a length of 624 and initially these values are obtained from the seed and, therefore, they cannot be predicted; however, after 624 iterations, the array of states is updated using a certain algorithm that we know. If we can determine the values of 624 values of states, we can apply the algorithm and determine the values of the key used and decipher the rest of the message, obtaining the values of the flag.

As we want to execute the function _"rnd.getrandbits(32)"_ 624 times before the encryption of the padding and the flag, we need to send a message of size 624\*4, as each 32 bit-word generated by the Mersenne Twister is going to be used to encrypt 4 chars of the message. After having a message and an encrypted response, we can discover the values of the flag used on the message we send. All of this can be presented in the following lines of code:

<pre><code>
msg2 = "A" * 2496
data = {"message": msg2}
resp = req.post("https://twisted-oblivion.is.hackthe.space/", data)
result = re.search(b"<code><pre>(.*)</pre></code>", resp.content)
encrypted_msg2_b64 = result.group(1)

msg2_encode = msg2.encode()

encrypted_msg2 = from64(encrypted_msg2_b64) #Source code: to64(bytes(out)).decode()

#I want to find out the key used for the first 2496 chars!
key_2496 = [msg2_encode[i] ^ encrypted_msg2[i] for i in range(len(msg2_encode))]
</code></pre>

Afterwards, we need to determine the first 624 values of the array of states. In order to do so, we are going to start by putting together the 32-bits word that resulted from the function. Afterwards, we are going to use z3 to resolve the equations that were used in these key values and calculate the values of the array of states. In the end of this part of the code, we are going to have the array of states of the MT algorithm.

<pre><code>
MT_states = []
for i in range (0, len(key_2496), 4):
    # each MT is a 32-bit int; in the source code, this ks were "divided" into 4 8-bit int. I need to join them together again to determine the values of MT exactly

    key_aux = ''
    for j in range(0,4):
        key_aux += bin(key_2496[i+j])[2:].zfill(8)
    key_aux = int(key_aux,2)

    solver = Solver()
    y1 = BitVec('y1', 32)
    y2 = BitVec('y2', 32)
    y3 = BitVec('y3', 32)
    y4 = BitVec('y4', 32)
    key = BitVecVal(key_aux,32)

    ''' 
    int y := MT[index]
    y := y xor ((y >> 11) and d)
    y := y xor ((y << 7) and b)
    y := y xor ((y << 15) and c)
    y := y xor (y >> 18)
    '''

    solver.add( y3  == y4 ^ ( LShR(y4, 11) & 0xffffffff) )
    solver.add( y2  == y3 ^ ((y3 << 7 ) & 0x9d2c5680) )
    solver.add( y1  == y2 ^ ((y2 << 15) & 0xefc60000) )
    solver.add( key == y1 ^ LShR( y1,18) )

    check = solver.check()
    if(check == sat):
        model = solver.model()
        MT_states.append(model[y4].as_long())
</code></pre>

With the array of states, we can apply the algorithm of function _"twist()"_ from Mersenne Twister to discover the next array of states. This is followed by the discovery of the values of the key. Lastly, with these values of the key, we can decipher the encrypted message and discover the flag.

<pre><code>
key_discover = []

r = 31
a = 0x9908b0df
m = 397
lower_mask = (1 << r) - 1
upper_mask = (~lower_mask)

#Determine the next states:
for i in range(0, (len(encrypted_msg2)-2496)//4 + 1):

    #Obtain the next states of MT
    x = ((MT_states[i] & upper_mask) + (MT_states[(i+1) % 624] & lower_mask))
    xA = x >> 1
    if (x % 2) != 0: 
        xA = xA ^ a
    MT_states[i] = MT_states[(i + m) % 624] ^ xA

    #Obtain the int
    y = MT_states[i]
    y = y ^ ((y >> 11) & 0xffffffff)
    y = y ^ ((y << 7) & 0x9d2c5680) 
    y = y ^ ((y << 15) & 0xefc60000) 
    y = y ^ (y >> 18)

    #Divide this array of 32-bits ints into 4 ints of 8-bit.
    ks = bin(y)[2:].zfill(32)
    for j in range(0, 32, 8):
        key_discover.append(int(ks[j:j+8], 2))


rest_encrypted_msg = len(encrypted_msg2) - 2496
out = [key_discover[i] ^ encrypted_msg2[i+2496] for i in range(rest_encrypted_msg)]
print(bytes(out).decode())
</code></pre>

https://www.w3schools.com/python/python_operators.asp
https://www.programiz.com/python-programming/methods/built-in/int
https://www.programiz.com/python-programming/methods/string/zfill
https://sites.pitt.edu/~naraehan/python2/tutorial9.html
https://docs.python.org/3/library/base64.html
https://www.mathworks.com/matlabcentral/answers/120624-opposite-operation-of-xor
https://z3prover.github.io/api/html/ml/Z3.BitVector.html
https://z3prover.github.io/api/html/
https://www.techiedelight.com/convert-binary-string-to-integer-python/
https://is.hackthe.space/cms/files/535abbb8fe8b0476f7714d237bb3e6d2c3c0950174ac7da721d5d8e320a056f7/IS22_-_Formal_Verification.pdf
https://en.wikipedia.org/wiki/Mersenne_Twister#Disadvantages
https://www.schutzwerk.com/en/43/posts/attacking_a_random_number_generator/
https://docs.python.org/3/library/random.html
https://www.geeksforgeeks.org/python-bitwise-operators/

Solution
--------
_Provide a minimal patch that makes the encryption key not recoverable._

As stated, the main problem with this webpage is the encryption algorithm chosen. In order to turn this encryption scheme secure, we should use a pseudorandom number generator that is perfectly secure. If we follow the suggestion given in the description of the library *random*, we could use the library secrets, as this library _"is used for generating cryptographically strong random numbers"_. 

The changes made to the source code should be the following:
<pre><code>
[...]

# randomly initialize the seed
# rnd = random.Random(secrets.token_bytes(16))
    
# get the maximum size of the plaintext message, add 2 for the separators
msg_max_len = len(msg) + pad_max_len + len(FLAG) + 2

# generate the keystream
key = []
for i in range(msg_max_len//4 + 1):
    ks = bin(secretes.randbits(32))[2:].zfill(32)
    # split a 32bit word into 4 keys of 8bit each
    for j in range(0, 32, 8):
        key.append(int(ks[j:j+8], 2))

[...]
</code></pre>



